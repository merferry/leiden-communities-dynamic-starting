\subsection{Our Parallel Naive-dynamic (ND) Leiden}
\label{sec:our-naive}

Algorithm \ref{alg:naive} details our multicore implementation of Naive dynamic (ND) Leiden. Here, vertices are assigned to communities based on the previous snapshot of the graph, with all vertices being processed regardless of edge deletions and insertions in the batch update. The algorithm accepts the current/updated graph snapshot $G^t$, edge deletions $\Delta^{t-}$ and insertions $\Delta^{t+}$ in the batch update, the previous community membership $C^{t-1}$ for each vertex, the weighted degree of each vertex $K^{t-1}$, and the total edge weight of each community $\Sigma^{t-1}$. The output includes the updated community memberships $C^t$, the updated weighted degrees $K^t$, and the updated total edge weights of communities $\Sigma^t$.

In the algorithm, we begin by defining two lambda functions for the Leiden algorithm: \texttt{isAffected()} (lines \ref{alg:naive--isaff-begin} to \ref{alg:naive--isaff-end}) and \texttt{inAffected} \texttt{Range()} (lines \ref{alg:naive--isaffrng-begin} to \ref{alg:naive--isaffrng-end}). These functions indicate that all vertices in the graph $G^t$ should be marked as affected and that these vertices can be incrementally marked as affected, respectively. Unlike previous approaches, we then use $K^{t-1}$ and $\Sigma^{t-1}$, along with the batch updates $\Delta^{t-}$ and $\Delta^{t+}$, to quickly compute $K^t$ and $\Sigma^t$, which are required for the local-moving phase of the Leiden algorithm (line \ref{alg:naive--auxliliary}). The lambda functions, along with the total vertex and edge weights, are then employed to run the Leiden algorithm and obtain\ignore{the} updated community assignments $C^t$ (line \ref{alg:naive--leiden}). Finally, $C^t$ is returned, along with $K^t$ and $\Sigma^t$ as\ignore{the} updated auxiliary information (line \ref{alg:naive--return}).




\subsection{Our Parallel Delta-screening (DS) Leiden}
\label{sec:our-delta}

Algorithm \ref{alg:delta} presents the pseudocode for our multicore implementation of Delta-screening (DS) Leiden. It employs modularity-based scoring to identify an approximate region of the graph where vertices are likely to change their community membership \cite{com-zarayeneh21}. It takes as input the current/updated graph snapshot $G^t$, edge deletions $\Delta^{t-}$ and insertions $\Delta^{t+}$ in the batch update, the previous community memberships of vertices $C^{t-1}$, the weighted degrees of vertices $K^{t-1}$, and the total edge weights of communities $\Sigma^{t-1}$. The algorithm outputs the updated community memberships $C^t$, weighted degrees $K^t$, and total edge weights of communities $\Sigma^t$. Prior to processing, the batch update --- which includes edge deletions $(i, j, w) \in \Delta^{t-}$ and insertions $(i, j, w) \in \Delta^{t+}$ --- are sorted separately by the source vertex ID $i$.

\input{src/alg-naive}
\input{src/alg-delta}

In the algorithm, we start by initializing a hashtable $H$ that maps communities to their associated weights, and we set the affected flags $\delta V$, $\delta E$, and $\delta C$, which indicate whether a vertex, its neighbors, or its community is affected by the batch update (lines \ref{alg:delta--init}). We then parallelly process edge deletions $\Delta^{t-}$ and insertions $\Delta^{t+}$. For each deletion $(i, j, w) \in \Delta^{t-}$ where vertices $i$ and $j$ belong to the same community, we mark the source vertex $i$, its neighbors, and its community as affected (lines \ref{alg:delta--loopdel-begin}-\ref{alg:delta--loopdel-end}). For each unique source vertex $i$ in insertions $(i, j, w) \in \Delta^{t+}$ where $i$ and $j$ belong to different communities, we determine the community $c^*$ with the highest delta-modularity if $i$ moves to one of its neighboring communities, marking $i$, its neighbors, and the community $c^*$ as affected (lines \ref{alg:delta--loopins-begin}-\ref{alg:delta--loopins-end}). We disregard deletions between different communities and insertions within the same community. Using the affected neighbor $\delta E$ and community flags $\delta C$, we mark affected vertices in $\delta V$ (lines \ref{alg:delta--loopaff-begin}-\ref{alg:delta--loopaff-end}). Subsequently, similar to ND Leiden, we utilize $K^{t-1}$ and $\Sigma^{t-1}$, along with $\Delta^{t-}$ and $\Delta^{t+}$, to quickly derive $K^t$ and $\Sigma^t$ (line \ref{alg:naive--auxliliary}). We define the necessary lambda functions \texttt{isAffected()} (lines \ref{alg:delta--isaff-begin}-\ref{alg:delta--isaff-end}) and \texttt{inAffectedRange()} (lines \ref{alg:delta--isaffrng-begin}-\ref{alg:delta--isaffrng-end}), and execute the Leiden algorithm, resulting in updated community assignments $C^t$ (line \ref{alg:delta--leiden}). Finally, we return\ignore{the} updated community memberships $C^t$ along with $K^t$ and $\Sigma^t$ as\ignore{the} updated auxiliary information (line \ref{alg:delta--return}).




\subsection{Our Parallel Dynamic Frontier (DF) Leiden}
\label{sec:our-frontier}

Algorithm \ref{alg:frontier} presents the pseudocode for our Parallel Dynamic Frontier (DF) Leiden. It takes as input the updated graph snapshot $G^t$, edge deletions $\Delta^{t-}$ and insertions $\Delta^{t+}$ from the batch update, the previous community assignments $C^{t-1}$ for each vertex, the previous weighted degrees $K^{t-1}$ of vertices, and the previous total edge weights $\Sigma^{t-1}$ of communities. It outputs the updated community memberships $C^t$ for vertices, the updated weighted degrees $K^t$ of vertices, and the updated total edge weights $\Sigma^t$ of communities.

\input{src/alg-frontier}

In the algorithm, we initially identify a set of affected vertices whose communities may directly change due to batch updates by marking them in the flag vector $\delta V$. This is achieved by marking the endpoints of edge deletions $\Delta^{t-}$ that lie within the same community (lines \ref{alg:frontier--loopdel-begin}-\ref{alg:frontier--loopdel-end}), and by marking the endpoints of edge insertions $\Delta^{t+}$ that lie in disjoint communities (lines \ref{alg:frontier--loopins-begin}-\ref{alg:frontier--loopins-end}). Subsequently, three lambda functions are defined for the Leiden algorithm: \texttt{isAffected()} (lines \ref{alg:frontier--isaff-begin}-\ref{alg:frontier--isaff-end}), \texttt{inAffectedRange()} (lines \ref{alg:frontier--isaffrng-begin}-\ref{alg:frontier--isaffrng-end}), and \texttt{onChange()} (lines \ref{alg:frontier--onchg-begin}-\ref{alg:frontier--onchg-end}). These functions indicate that a set of vertices are initially marked as affected, that all vertices in the graph can be incrementally marked as affected, and that the neighbors of a vertex are marked as affected if it changes its community membership, respectively. It is important to note that the set of affected vertices will expand automatically due to vertex pruning optimization used in our Parallel Leiden algorithm (Algorithm \ref{alg:leiden}). Thus, \texttt{onChange()} reflects what the DF approach would do in the absence of vertex pruning. Additionally, unlike existing approaches, we utilize $K^{t-1}$ and $\Sigma^{t-1}$, alongside the batch updates $\Delta^{t-}$ and $\Delta^{t+}$, to efficiently compute $K^t$ and $\Sigma^t$ required for the local-moving phase of the Leiden algorithm (line \ref{alg:frontier--auxiliary}). These lambda functions and the total vertex/edge weights are then employed to execute the Leiden algorithm and obtain the updated community assignments $C^t$ (line \ref{alg:frontier--leiden}). Finally, we return $C^t$, alongside $K^t$ and $\Sigma^t$\ignore{, serving as the updated auxiliary information} (line \ref{alg:frontier--return}).




\subsection{Our Dynamic-supporting Parallel Leiden}
\label{sec:our-leiden}

The main step of our Dynamic-supporting Parallel Leiden is outlined in Algorithm \ref{alg:leiden}. In contrast to our implementation of Static Leiden \cite{sahu2023gveleiden}, this algorithm, in addition to the current graph snapshot $G^t$, accepts the prior community membership of each vertex $C^{t-1}$, the revised weighted degree of each vertex $K^t$, the updated total edge weight of each community $\Sigma^t$, and a set of lambda functions $F$ determining whether a vertex is influenced or can be progressively identified as influenced (within the affected range). It yields the updated community memberships of vertices $C^t$.

\input{src/alg-leiden}

In the algorithm, we start by marking the affected vertices as unprocessed (lines \ref{alg:leiden--mark-begin}-\ref{alg:leiden--mark-end}). Next, during the initialization phase, several parameters are set: the community membership of each vertex $C$ in $G^t$, the total edge weight of each vertex $K'$, the total edge weight of each community $\Sigma'$, and the community membership $C'$ of each vertex in the current (super-vertex) graph $G'$. Additionally, an initial set of changed communities $\Delta C'$ is determined based on the batch update as described in Section \ref{sec:approach} (lines \ref{alg:leiden--init-begin}-\ref{alg:leiden--init-end}). Following initialization, a series of passes is carried out, limited by $MAX\_PASSES$, with each pass comprising local-moving, refinement, and aggregation phases (lines \ref{alg:leiden--passes-begin}-\ref{alg:leiden--passes-end}). In each pass, the Leiden algorithmâ€™s local-moving phase (Algorithm \ref{alg:leidenlm}) is executed to optimize community assignments (line \ref{alg:leiden--local-move}). However, this phase may result in poorly connected or internally disconnected communities. Therefore, the communities must be refined. For selective refinement --- which enhances the algorithm's efficiency for small batch updates --- the community IDs are renumbered so that each community ID corresponds to one of its constituent vertices. Additionally, the total edge weights of communities and the flags for changed communities are updated accordingly (see Algorithm \ref{alg:leidensr}), and changed communities are broken up, isolating their constituent vertices into separate communities. The total weights of these communities are adjusted as needed. The refinement phase, executed by \texttt{leidenRefine()}, optimizes the community assignments for each vertex within its community boundaries $C'_B$ obtained from the local-moving phase (line \ref{alg:leiden--refine}). If the local-moving phase converges after a single iteration, indicating global convergence, the passes are halted (line \ref{alg:leiden--globally-converged}). If convergence is not achieved, the aggregation phase is performed. This involves renumbering the communities, updating top-level community memberships $C$ using dendrogram lookup, performing the aggregation process (Algorithm \ref{alg:leidenag}), and updating the weighted degrees of vertices $K'$ and total edge weights of communities $\Sigma'$ in the super-vertex graph. Following this, to prepare for the next pass of the algorithm, we mark all vertices in this graph as unprocessed, initialize community memberships based on the refinement phase, mark all communities as changed for the next pass, and adjust the convergence threshold $\tau$ by scaling it (line \ref{alg:leiden--threshold-scaling}). The next pass then begins (line \ref{alg:leiden--passes-begin}). After all passes, the top-level community memberships $C$ of each vertex in $G^t$ are updated one final time via dendrogram lookup before being returned (lines \ref{alg:leiden--lookup-last}-\ref{alg:leiden--return}).

We now discuss about two support functions \textsc{changedCommunities()} and \textsc{breakChangedCommunities()}. The function \textsc{changedCommunities()} takes as input the batch update, consisting of edge deletions $\Delta^{t-}$ and insertions $\Delta^{t+}$, and marks a community as changed if both the endpoints of edge deletions and insertions belong to the same community. However, this is only done for ND, DS, and DF Leiden --- all communities are considered to haved changed with Static Leiden. Finally, the function \textsc{breakChangedCommunities()} splits changed communities, as indicated with the changed communities flag $\Delta C'$, into vertices belonging to isolated communities.


\subsubsection{Local-moving phase of our Parallel Leiden}

The pseudocode for the local-moving phase\ignore{of our Parallel Leiden} is presented in Algorithm \ref{alg:leidenlm}. It iteratively moves vertices among communities in order to maximize modularity. Here, the \texttt{leidenMove()} function operates on the current graph $G'$, community membership $C'$, total edge weight of each vertex $K'$, total edge weight of each community $\Sigma'$, changed communities flag vector $\Delta C'$, and a set of lambda functions as inputs, yielding the number of iterations performed $l_i$.

\input{src/alg-leidenlm}

Lines \ref{alg:leidenlm--iterations-begin}-\ref{alg:leidenlm--iterations-end} encapsulate the primary loop of the local-moving phase. In line \ref{alg:leidenlm--init-deltaq}, we initialize the total delta-modularity per iteration $\Delta Q$. Subsequently, in lines \ref{alg:leidenlm--loop-vertices-begin}-\ref{alg:leidenlm--loop-vertices-end}, we concurrently iterate over unprocessed vertices. For each vertex $i$, we perform vertex pruning by marking $i$ as processed (line \ref{alg:leidenlm--prune}). Next, we verify if $i$ falls within the affected range (i.e., it is permitted to be incrementally marked as affected), and if not, we proceed to the next vertex (line \ref{alg:leidenlm--affrng}). For each unskipped vertex $i$, we scan communities connected to $i$ (line \ref{alg:leidenlm--scan}), excluding itself, ascertain the optimal community $c*$ to move $i$ to (line \ref{alg:leidenlm--best-community-begin}), compute the delta-modularity of moving $i$ to $c*$ (line \ref{alg:leidenlm--best-community-end}), update the community membership of $i$ (lines \ref{alg:leidenlm--perform-move-begin}-\ref{alg:leidenlm--perform-move-end}), and mark its neighbors as unprocessed (line \ref{alg:leidenlm--remark}) if a superior community is identified. It is worth noting that this practice of marking neighbors of $i$ as unprocessed, which is part of the vertex pruning optimization, also aligns with algorithm of DF Leiden --- which marks its neighbors as affected, when a vertex changes its community. Thus, vertex pruning facilitates incremental expansion of the set of affected vertices without requiring any extra code. Further, for ND, DS, and DF Leiden, we mark the source $c$ and target communities $c^*$ of the migrating vertex $i$ as changed. With Static Leiden, all communities are always refined. In line \ref{alg:leidenlm--locally-converged}, we examine whether the local-moving phase has achieved convergence (locally); if so, the loop is terminated (or if $MAX\_ITERATIONS$ is reached). Finally, in line \ref{alg:leidenlm--return}, we return the number of iterations performed\ignore{by the local-moving phase} $l_i$.


\subsubsection{Refinement phase of our Parallel Leiden}

The pseudocode outlining the refinement phase of our Parallel Leiden is presented in Algorithm \ref{alg:leidenlm}. This phase closely resembles the local-moving phase but incorporates the community membership obtained for each vertex as a \textit{community bound}. In this phase, each vertex is required to select a community within its community bound to join, aiming to maximize modularity through iterative movements between communities, akin to the local-moving phase. At the onset of the refinement phase, the community membership of each vertex is reset so that each vertex initially forms its own community. The \texttt{leidenRefine()} function is employed, taking as input the current graph $G'$, the community bound of each vertex $C'_B$, the initial community membership $C'$ of each vertex, the total edge weight of each vertex $K'$, the initial total edge weight of each community $\Sigma'$, changed communities flag vector $\Delta C'$, and the current tolerance per iteration $\tau$, and returns the number of iterations executed $l_j$.

\input{src/alg-leidenre}

Lines \ref{alg:leidenre--loop-vertices-begin}-\ref{alg:leidenre--loop-vertices-end} embody the central aspect of the refinement phase. During this phase, we execute what is termed the constrained merge procedure \cite{com-traag19}. The essence of this procedure lies in enabling vertices, within each community boundary, to create sub-communities solely by permitting isolated vertices (i.e., vertices belonging to their own community) to alter their community affiliation. This process divides any internally-disconnected communities identified during the local-moving phase and prevents the emergence of new disconnected communities. Specifically, for every isolated vertex $i$ (line \ref{alg:leidenre--check-isolated}), we explore communities connected to $i$ within the \textit{same community boundary} - excluding itself (line \ref{alg:leidenre--scan}). The refinement phase is skipped for a vertex if its community has not been flagged as changed ($\Delta C'[c] = 0$), or if another vertex has joined its community, as indicated by the total community weight no longer matching the total edge weight of the vertex. Subsequently, we determine the optimal community $c*$ for relocating $i$ (line \ref{alg:leidenre--best-community-begin}), and assess the delta-modularity of transferring $i$ to $c*$ (line \ref{alg:leidenre--best-community-end}). If a superior community is identified, we attempt to update the community affiliation of $i$ provided it remains isolated (lines \ref{alg:leidenre--perform-move-begin}-\ref{alg:leidenre--perform-move-end}). Note that we do not migrate the vertex $i$ to community $c^*$ if the vertex representing $c^*$ has itself moved to another community.


\subsubsection{Aggregation phase of our Parallel Leiden}

The pseudocode for the aggregation phase is presented in Algorithm \ref{alg:leidenag}, wherein communities are merged into super-vertices. Specifically, the \texttt{leidenAggre} \texttt{gate()} function within this algorithm takes the current graph $G'$ and the community membership $C'$ as inputs and produces the super-vertex graph $G''$.

\input{src/alg-leidenag}

In the algorithm, the process begins by obtaining the offsets array for the community vertices in the CSR format, denoted as $G'_{C'}.offsets$, within lines \ref{alg:leidenag--coff-begin} to \ref{alg:leidenag--coff-end}. This starts with counting the number of vertices in each community using \texttt{countCommunityVertices()}, followed by performing an exclusive scan on the resulting array. Next, within lines \ref{alg:leidenag--comv-begin} to \ref{alg:leidenag--comv-end}, we concurrently traverse all vertices, atomically placing the vertices associated with each community into the community graph CSR $G'_{C'}$. Following this, the offsets array for the super-vertex graph CSR is computed by estimating the degree of each super-vertex within lines \ref{alg:leidenag--yoff-begin} to \ref{alg:leidenag--yoff-end}. This involves calculating the total degree of each community using \texttt{communityTotalDegree()}, followed by another exclusive scan. As a result, the super-vertex graph CSR is organized with intervals for the edges and weights array of each super-vertex. Then, in lines \ref{alg:leidenag--y-begin} to \ref{alg:leidenag--y-end}, we iterate over all communities $c \in [0, |\Gamma|)$ in parallel using dynamic loop scheduling, with a chunk size of $2048$ for both Static Leiden and a chunk size of $32$ for ND, DS, and DF Leiden. During this phase, all communities $d$ (and their respective edge weights $w$) connected to each vertex $i$ in community $c$ are included (via \texttt{scanCommunities()}, described in Algorithm \ref{alg:leidenlm}) in the per-thread hashtable $H_t$. Once $H_t$ contains all the connected communities and their weights, they are atomically added as edges to super-vertex $c$ in the super-vertex graph $G''$. Finally, in line \ref{alg:leidenag--return}, we return the super-vertex graph $G''$.


\subsubsection{Renumbering communities by ID of a vertex within}

We now describe Algorithm \ref{alg:leidensr}, which outlines a method for renumbering communities based on their internal vertices. The goal is to ensure that each community is identified by the ID of one of its member vertices. The inputs to the algorithm include the current graph $G'$, the vertex community assignments $C'$, the total edge weights of communities $\Sigma'$, and the changed communities flags $\Delta C'$.

The algorithm begins by initializing several essential data structures ($C''$, $\Sigma''$, $\Delta C''$, and $C'_v$) to empty or default values (line \ref{alg:leidensr--init}). These structures will store updated community memberships, edge weights, change flags, and help select a representative vertex for each community. Next, for each vertex $i$, the current community ID $c'$ is retrieved from $C'[i]$. If no representative vertex has been assigned yet for community $c'$ (i.e., $C'_v[c']$ is empty), vertex $i$ is designated as the representative for community $c'$. Following this, the second parallel loop processes all communities $c' \in \Gamma'$, the set of communities in the original graph. For each community $c'$, the representative vertex $c''$ is retrieved from the previous step, and the total edge weight $\Sigma'[c']$ and the change flag $\Delta C'[c']$ are reorganized into the corresponding updated versions $\Sigma''[c'']$ and $\Delta C''[c'']$. Finally, the third parallel loop updates the community membership of each vertex based on the representative vertex chosen for its community. For each vertex $i$, the algorithm finds the current community $C'[i]$, retrieves the representative vertex for that community, and reassigns vertex $i$ to the new community ID corresponding to its representative. Once the community memberships are updated, the algorithm performs an in-place update of the original structures: the community memberships $C'$, total edge weights $\Sigma'$, and change flags $\Delta C'$ are replaced with the updated versions $C''$, $\Sigma''$, and $\Delta C''$.

\input{src/alg-leidensr}


\subsection{Updating vertex/community weights}
\label{sec:our-update}

We will now elaborate on the parallel algorithm designed to compute the updated weighted degree of each vertex $K^t$ and the total edge weight of each community $\Sigma^t$. This algorithm operates based on the previous community memberships of vertices $C^{t-1}$, the weighted degrees of vertices $K^{t-1}$, the total edge weights of communities, and the batch update, which encompasses edge deletions $\Delta^{t-}$ and insertions $\Delta^{t+}$. The pseudocode for this algorithm is presented in Algorithm \ref{alg:update}.

In the algorithm, initialization of $K$ and $\Sigma$, representing the weighted degree of each vertex and the total edge weight of each community, respectively, occurs first (line \ref{alg:update--init}). Subsequently, utilizing multiple threads, we iterate over sets of edge deletions $\Delta^{t-}$ (lines \ref{alg:update--loopdel-begin}-\ref{alg:update--loopdel-end}) and edge insertions $\Delta^{t+}$ (lines \ref{alg:update--loopins-begin}-\ref{alg:update--loopins-end}). For each edge deletion $(i, j, w)$ in $\Delta^{t-}$, we ascertain the community $c$ of vertex $i$ based on the previous community assignment $C^{t-1}$ (line \ref{alg:update--delc}). If vertex $i$ belongs to the current thread's work-list, its weighted degree is decremented by $w$ (line \ref{alg:update--delk}), and if community $c$ belongs to the work-list, its total edge weight is also decremented by $w$ (line \ref{alg:update--delsigma}). Similarly, for each edge insertion $(i, j, w)$ in $\Delta^{t+}$, adjustments are made to the weighted degree of vertex $i$ and the total edge weight of its community. Finally, updated values of $K$ and $\Sigma$ for each vertex and community are returned for further processing (line \ref{alg:update--return}).

\input{src/alg-update}
