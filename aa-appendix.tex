\subsection{Our Parallel Naive-dynamic (ND) Leiden}
\label{sec:our-naive}

Algorithm \ref{alg:naive} details our multicore implementation of Naive dynamic (ND) Leiden. Here, vertices are assigned to communities based on the previous snapshot of the graph, with all vertices being processed regardless of edge deletions and insertions in the batch update. The algorithm accepts the previous graph snapshot $G^{t-1}$, the current graph snapshot $G^t$, edge deletions $\Delta^{t-}$ and insertions $\Delta^{t+}$ from the batch update, the previous community membership $C^{t-1}$ for each vertex, the weighted degree of each vertex $K^{t-1}$, and the total edge weight of each community $\Sigma^{t-1}$. The output includes the updated community memberships $C^t$, the updated weighted degrees $K^t$, and the updated total edge weights of communities $\Sigma^t$.

In the algorithm, we begin by defining two lambda functions for the Leiden algorithm: \texttt{isAffected()} (lines \ref{alg:naive--isaff-begin} to \ref{alg:naive--isaff-end}) and \texttt{inAffected} \texttt{Range()} (lines \ref{alg:naive--isaffrng-begin} to \ref{alg:naive--isaffrng-end}). These functions indicate that all vertices in the graph $G^t$ should be marked as affected and that these vertices can be incrementally marked as affected, respectively. Unlike previous approaches, we then use $K^{t-1}$ and $\Sigma^{t-1}$, along with the batch updates $\Delta^{t-}$ and $\Delta^{t+}$, to quickly compute $K^t$ and $\Sigma^t$, which are required for the local-moving phase of the Leiden algorithm (line \ref{alg:naive--auxliliary}). The lambda functions, along with the total vertex and edge weights, are then employed to run the Leiden algorithm and obtain\ignore{the} updated community assignments $C^t$ (line \ref{alg:naive--leiden}). Finally, $C^t$ is returned, along with $K^t$ and $\Sigma^t$ as\ignore{the} updated auxiliary information (line \ref{alg:naive--return}).




\subsection{Our Parallel Delta-screening (DS) Leiden}
\label{sec:our-delta}

Algorithm \ref{alg:delta} presents the pseudocode for our multicore implementation of Delta-screening (DS) Leiden. It employs modularity-based scoring to identify an approximate region of the graph where vertices are likely to change their community membership \cite{com-zarayeneh21}. It takes as input the previous graph snapshot $G^{t-1}$, the current snapshot $G^t$, edge deletions $\Delta^{t-}$ and insertions $\Delta^{t+}$ from the batch update, the previous community memberships of vertices $C^{t-1}$, the weighted degrees of vertices $K^{t-1}$, and the total edge weights of communities $\Sigma^{t-1}$. The algorithm outputs the updated community memberships $C^t$, weighted degrees $K^t$, and total edge weights of communities $\Sigma^t$. Prior to processing, the batch update --- which includes edge deletions $(i, j, w) \in \Delta^{t-}$ and insertions $(i, j, w) \in \Delta^{t+}$ --- is sorted separately by the source vertex ID $i$.

\input{src/alg-naive}
\input{src/alg-delta}

In the algorithm, we start by initializing a hashtable $H$ that maps communities to their associated weights, and we set the affected flags $\delta V$, $\delta E$, and $\delta C$, which indicate whether a vertex, its neighbors, or its community is affected by the batch update (lines \ref{alg:delta--init}). We then parallelly process edge deletions $\Delta^{t-}$ and insertions $\Delta^{t+}$. For each deletion $(i, j, w) \in \Delta^{t-}$ where vertices $i$ and $j$ belong to the same community, we mark the source vertex $i$, its neighbors, and its community as affected (lines \ref{alg:delta--loopdel-begin}-\ref{alg:delta--loopdel-end}). For each unique source vertex $i$ in insertions $(i, j, w) \in \Delta^{t+}$ where $i$ and $j$ belong to different communities, we determine the community $c^*$ with the highest delta-modularity if $i$ moves to one of its neighboring communities, marking $i$, its neighbors, and the community $c^*$ as affected (lines \ref{alg:delta--loopins-begin}-\ref{alg:delta--loopins-end}). We disregard deletions between different communities and insertions within the same community. Using the affected neighbor $\delta E$ and community flags $\delta C$, we mark affected vertices in $\delta V$ (lines \ref{alg:delta--loopaff-begin}-\ref{alg:delta--loopaff-end}). Subsequently, similar to ND Leiden, we utilize $K^{t-1}$ and $\Sigma^{t-1}$, along with $\Delta^{t-}$ and $\Delta^{t+}$, to quickly derive $K^t$ and $\Sigma^t$ (line \ref{alg:naive--auxliliary}). We define the necessary lambda functions \texttt{isAffected()} (lines \ref{alg:delta--isaff-begin}-\ref{alg:delta--isaff-end}) and \texttt{inAffectedRange()} (lines \ref{alg:delta--isaffrng-begin}-\ref{alg:delta--isaffrng-end}), and execute the Leiden algorithm, resulting in updated community assignments $C^t$ (line \ref{alg:delta--leiden}). Finally, we return\ignore{the} updated community memberships $C^t$ along with $K^t$ and $\Sigma^t$ as\ignore{the} updated auxiliary information (line \ref{alg:delta--return}).




\subsection{Our Parallel Dynamic Frontier (DF) Leiden}
\label{sec:our-frontier}

Algorithm \ref{alg:frontier} presents the pseudocode for our Parallel Dynamic Frontier (DF) Leiden. It takes as input the previous graph snapshot $G^{t-1}$, the current graph snapshot $G^t$, edge deletions $\Delta^{t-}$ and insertions $\Delta^{t+}$ from the batch update, the previous community assignments $C^{t-1}$ for each vertex, the previous weighted degrees $K^{t-1}$ of vertices, and the previous total edge weights $\Sigma^{t-1}$ of communities. It outputs the updated community memberships $C^t$ for vertices, the updated weighted degrees $K^t$ of vertices, and the updated total edge weights $\Sigma^t$ of communities.

\input{src/alg-frontier}

In the algorithm, we initially identify a set of affected vertices whose communities may directly change due to batch updates by marking them in the flag vector $\delta V$. This is achieved by marking the endpoints of edge deletions $\Delta^{t-}$ that lie within the same community (lines \ref{alg:frontier--loopdel-begin}-\ref{alg:frontier--loopdel-end}), and by marking the endpoints of edge insertions $\Delta^{t+}$ that lie in disjoint communities (lines \ref{alg:frontier--loopins-begin}-\ref{alg:frontier--loopins-end}). Subsequently, three lambda functions are defined for the Leiden algorithm: \texttt{isAffected()} (lines \ref{alg:frontier--isaff-begin}-\ref{alg:frontier--isaff-end}), \texttt{inAffectedRange()} (lines \ref{alg:frontier--isaffrng-begin}-\ref{alg:frontier--isaffrng-end}), and \texttt{onChange()} (lines \ref{alg:frontier--onchg-begin}-\ref{alg:frontier--onchg-end}). These functions indicate that a set of vertices are initially marked as affected, that all vertices in the graph can be incrementally marked as affected, and that the neighbors of a vertex are marked as affected if it changes its community membership, respectively. It is important to note that the set of affected vertices will expand automatically due to vertex pruning optimization used in our Parallel Leiden algorithm (Algorithm \ref{alg:leiden}). Thus, \texttt{onChange()} reflects what the DF approach would do in the absence of vertex pruning. Additionally, unlike existing approaches, we utilize $K^{t-1}$ and $\Sigma^{t-1}$, alongside the batch updates $\Delta^{t-}$ and $\Delta^{t+}$, to efficiently compute $K^t$ and $\Sigma^t$ required for the local-moving phase of the Leiden algorithm (line \ref{alg:frontier--auxiliary}). These lambda functions and the total vertex/edge weights are then employed to execute the Leiden algorithm and obtain the updated community assignments $C^t$ (line \ref{alg:frontier--leiden}). Finally, we return $C^t$, alongside $K^t$ and $\Sigma^t$\ignore{, serving as the updated auxiliary information} (line \ref{alg:frontier--return}).




\subsection{Our Dynamic-supporting Parallel Leiden}
\label{sec:our-leiden}

The main step of our Dynamic-supporting Parallel Leiden is outlined in Algorithm \ref{alg:leiden}. In contrast to our implementation of Static Leiden \cite{sahu2023gveleiden}, this algorithm, in addition to the current graph snapshot $G^t$, accepts the prior community membership of each vertex $C^{t-1}$, the revised weighted degree of each vertex $K^t$, the updated total edge weight of each community $\Sigma^t$, and a set of lambda functions $F$ determining whether a vertex is influenced or can be progressively identified as influenced (within the affected range). It yields the updated community memberships of vertices $C^t$.

\input{src/alg-leiden}

In the algorithm, we begin by marking affected vertices as unprocessed (lines \ref{alg:leiden--mark-begin}-\ref{alg:leiden--mark-end}). Following this, the initialization phase initializes various parameters: the community membership of each vertex $C$ in $G^t$, the total edge weight of each vertex $K'$, the total edge weight of each community $\Sigma'$, and the community membership $C'$ of each vertex in the current/super-vertex graph $G'$ (lines \ref{alg:leiden--init-begin}-\ref{alg:leiden--init-end}). Subsequently, a series of passes (limited to $MAX\_PASSES$) comprising local-moving and aggregation phases are conducted (lines \ref{alg:leiden--passes-begin}-\ref{alg:leiden--passes-end}). Within each pass, the local-moving phase of the Leiden algorithm (Algorithm \ref{alg:leidenlm}) is executed to optimize community assignments (line \ref{alg:leiden--local-move}). Then, the community bound of each vertex is set for the refinement phase, and the memberships of vertices and the total weights of communities are reset as singleton vertices (line \ref{alg:leiden--reset-again}). The refinement phase, invoked by \texttt{leidenRefine()}, optimizes the community assignments of each vertex within its community bound (line \ref{alg:leiden--refine}). If the local-moving phase converges in a single iteration, indicating global convergence, the passes are terminated (line \ref{alg:leiden--globally-converged}). Alternatively, if the drop in community count $|\Gamma|$ is deemed insignificant, indicating diminishing returns, the current pass is halted (line \ref{alg:leiden--aggregation-tolerance}). If convergence conditions are not met, the aggregation phase is executed, involving community renumbering, updating top-level community memberships $C$ using dendrogram lookup, performing the aggregation phase (Algorithm \ref{alg:leidenag}), and adjusting the convergence threshold for subsequent passes via threshold scaling (line \ref{alg:leiden--threshold-scaling}). The subsequent pass commences (line \ref{alg:leiden--passes-begin}). After all passes, a final update of the top-level community membership $C$ of each vertex in $G^t$ is done via dendrogram lookup before returning it (lines \ref{alg:leiden--lookup-last}-\ref{alg:leiden--return}).


\subsubsection{Local-moving phase of our Parallel Leiden}

The pseudocode for the local-moving phase\ignore{of our Parallel Leiden} is presented in Algorithm \ref{alg:leidenlm}. It iteratively moves vertices among communities in order to maximize modularity. Here, the \texttt{leidenMove()} function operates on the current graph $G'$, community membership $C'$, total edge weight of each vertex $K'$, total edge weight of each community $\Sigma'$, and a set of lambda functions as inputs, yielding the number of iterations performed $l_i$.

\input{src/alg-leidenlm}

Lines \ref{alg:leidenlm--iterations-begin}-\ref{alg:leidenlm--iterations-end} encapsulate the primary loop of the local-moving phase. In line \ref{alg:leidenlm--init-deltaq}, we initialize the total delta-modularity per iteration $\Delta Q$. Subsequently, in lines \ref{alg:leidenlm--loop-vertices-begin}-\ref{alg:leidenlm--loop-vertices-end}, we concurrently iterate over unprocessed vertices. For each vertex $i$, we perform vertex pruning by marking $i$ as processed (line \ref{alg:leidenlm--prune}). Next, we verify if $i$ falls within the affected range (i.e., it is permitted to be incrementally marked as affected), and if not, we proceed to the next vertex (line \ref{alg:leidenlm--affrng}). For each unskipped vertex $i$, we scan communities connected to $i$ (line \ref{alg:leidenlm--scan}), excluding itself, ascertain the optimal community $c*$ to move $i$ to (line \ref{alg:leidenlm--best-community-begin}), compute the delta-modularity of moving $i$ to $c*$ (line \ref{alg:leidenlm--best-community-end}), update the community membership of $i$ (lines \ref{alg:leidenlm--perform-move-begin}-\ref{alg:leidenlm--perform-move-end}), and mark its neighbors as unprocessed (line \ref{alg:leidenlm--remark}) if a superior community is identified. It's worth noting that this practice of marking neighbors of $i$ as unprocessed, which is part of the vertex pruning optimization, also aligns with algorithm of DF Leiden --- which marks its neighbors as affected, when a vertex changes its community. Thus, vertex pruning facilitates incremental expansion of the set of affected vertices without requiring any extra code. In line \ref{alg:leidenlm--locally-converged}, we examine whether the local-moving phase has achieved convergence (locally); if so, the loop is terminated (or if $MAX\_ITERATIONS$ is reached). Finally, in line \ref{alg:leidenlm--return}, we return the number of iterations performed\ignore{by the local-moving phase} $l_i$.


\subsubsection{Refinement phase of our Parallel Leiden}

The pseudocode outlining the refinement phase of our Parallel Leiden is presented in Algorithm \ref{alg:leidenlm}. This phase closely resembles the local-moving phase but incorporates the community membership obtained for each vertex as a \textit{community bound}. In this phase, each vertex is required to select a community within its community bound to join, aiming to maximize modularity through iterative movements between communities, akin to the local-moving phase. At the onset of the refinement phase, the community membership of each vertex is reset so that each vertex initially forms its own community. The \texttt{leidenRefine()} function is employed, taking as input the current graph $G'$, the community bound of each vertex $C'_B$, the initial community membership $C'$ of each vertex, the total edge weight of each vertex $K'$, the initial total edge weight of each community $\Sigma'$, and the current tolerance per iteration $\tau$, and returns the number of iterations executed $l_j$.

\input{src/alg-leidenre}

Lines \ref{alg:leidenre--loop-vertices-begin}-\ref{alg:leidenre--loop-vertices-end} embody the central aspect of the refinement phase. During this phase, we execute what is termed the constrained merge procedure \cite{com-traag19}. The essence of this procedure lies in enabling vertices, within each community boundary, to create sub-communities solely by permitting isolated vertices (i.e., vertices belonging to their own community) to alter their community affiliation. This process divides any internally-disconnected communities identified during the local-moving phase and prevents the emergence of new disconnected communities. Specifically, for every isolated vertex $i$ (line \ref{alg:leidenre--check-isolated}), we explore communities connected to $i$ within the \textit{same community boundary} - excluding itself (line \ref{alg:leidenre--scan}). Subsequently, we determine the optimal community $c*$ for relocating $i$ (line \ref{alg:leidenre--best-community-begin}), and assess the delta-modularity of transferring $i$ to $c*$ (line \ref{alg:leidenre--best-community-end}). If a superior community is identified, we endeavor to update the community affiliation of $i$ provided it remains isolated (lines \ref{alg:leidenre--perform-move-begin}-\ref{alg:leidenre--perform-move-end}).


\subsubsection{Aggregation phase of our Parallel Leiden}

The pseudocode for the aggregation phase is presented in Algorithm \ref{alg:leidenag}, wherein communities are merged into super-vertices. Specifically, the \texttt{leidenAggre} \texttt{gate()} function within this algorithm takes the current graph $G'$ and the community membership $C'$ as inputs and produces the super-vertex graph $G''$.

\input{src/alg-leidenag}

In the algorithm, the process initiates by acquiring the offsets array for the community vertices CSR $G'_{C'}.offsets$ within lines \ref{alg:leidenag--coff-begin}-\ref{alg:leidenag--coff-end}. Initially, this involves tallying the number of vertices associated with each community using \texttt{countCommunityVertices()}, followed by executing an exclusive scan operation on the array. Subsequently, within lines \ref{alg:leidenag--comv-begin}-\ref{alg:leidenag--comv-end}, we concurrently traverse all vertices, atomically assigning vertices linked with each community into the community graph CSR $G'_{C'}$. Moving forward, we determine the offsets array for the super-vertex graph CSR by approximating the degree of each super-vertex within lines \ref{alg:leidenag--yoff-begin}-\ref{alg:leidenag--yoff-end}. This involves computing the cumulative degree of each community utilizing \texttt{communityTotalDegree()} followed by executing an exclusive scan on the array. Consequently, the super-vertex graph CSR displays intervals between the edges and weights array of each super-vertex. Subsequent to this, within lines \ref{alg:leidenag--y-begin}-\ref{alg:leidenag--y-end}, we iterate over all communities $c \in [0, |\Gamma|)$. Here, we include all communities $d$ (alongside their respective edge weight $w$) connected to each vertex $i$ belonging to community $c$ (through \texttt{scanCommunities()} as defined in Algorithm \ref{alg:leidenlm}) into the per-thread hashtable $H_t$. Upon $H_t$ containing all communities (with their weights) linked to community $c$, we atomically append them as edges to super-vertex $c$ within the super-vertex graph $G''$. Ultimately, in line \ref{alg:leidenag--return}, we return\ignore{the super-vertex graph} $G''$.


\subsection{Updating vertex/community weights}
\label{sec:our-update}

We will now elaborate on the parallel algorithm designed to compute the updated weighted degree of each vertex $K^t$ and the total edge weight of each community $\Sigma^t$. This algorithm operates based on the previous community memberships of vertices $C^{t-1}$, the weighted degrees of vertices $K^{t-1}$, the total edge weights of communities, and the batch update, which encompasses edge deletions $\Delta^{t-}$ and insertions $\Delta^{t+}$. The pseudocode for this algorithm is presented in Algorithm \ref{alg:update}.

In the algorithm, initialization of $K$ and $\Sigma$, representing the weighted degree of each vertex and the total edge weight of each community, respectively, occurs first (line \ref{alg:update--init}). Subsequently, utilizing multiple threads, we iterate over sets of edge deletions $\Delta^{t-}$ (lines \ref{alg:update--loopdel-begin}-\ref{alg:update--loopdel-end}) and edge insertions $\Delta^{t+}$ (lines \ref{alg:update--loopins-begin}-\ref{alg:update--loopins-end}). For each edge deletion $(i, j, w)$ in $\Delta^{t-}$, we ascertain the community $c$ of vertex $i$ based on the previous community assignment $C^{t-1}$ (line \ref{alg:update--delc}). If vertex $i$ belongs to the current thread's work-list, its weighted degree is decremented by $w$ (line \ref{alg:update--delk}), and if community $c$ belongs to the work-list, its total edge weight is also decremented by $w$ (line \ref{alg:update--delsigma}). Similarly, for each edge insertion $(i, j, w)$ in $\Delta^{t+}$, adjustments are made to the weighted degree of vertex $i$ and the total edge weight of its community. Finally, updated values of $K$ and $\Sigma$ for each vertex and community are returned for further processing (line \ref{alg:update--return}).

\input{src/alg-update}
