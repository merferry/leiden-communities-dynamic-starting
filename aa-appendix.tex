\subsection{Our Parallel Naive-dynamic (ND) Leiden}
\label{sec:our-naive}

Algorithm \ref{alg:naive} presents our multicore implementation of Naive dynamic (ND) Leiden, where vertices are assigned to communities from the previous snapshot of the graph, and all vertices are processed irrespective of edge deletions and insertions in the batch update. Algorithm \ref{alg:naive} requires several inputs, including the previous $G^{t-1}$ and current graph snapshots $G^t$, edge deletions $\Delta^{t-}$ and insertions $\Delta^{t+}$ in the batch update, the previous community membership of each vertex $C^{t-1}$, weighted degree of each vertex $K^{t-1}$, and total edge weight of each community $\Sigma^{t-1}$. The output consists of the updated community memberships $C^t$, weighted-degrees $K^t$, and total edge weight of communities $\Sigma^t$.

In the algorithm, we start by defining two lambda functions for the Leiden algorithm, \texttt{isAffected()} (lines \ref{alg:naive--isaff-begin}-\ref{alg:naive--isaff-end}) and \texttt{inAffectedR} \texttt{ange()} (lines \ref{alg:naive--isaffrng-begin}-\ref{alg:naive--isaffrng-end}), which indicate that all vertices in the graph $G^t$ are to be marked as affected, and that all such vertices can be incrementally marked as affected, respectively. Unlike existing works, we then utilize $K^{t-1}$ and $\Sigma^{t-1}$, along with the batch update $\Delta^{t-}$ and $\Delta^{t+}$, to quickly obtain $K^t$ and $\Sigma^t$ which is needed in the local-moving phase of the Leiden algorithm (line \ref{alg:naive--auxliliary}). The lambda functions and the total vertex/edge weights are then used to run the Leiden algorithm, and obtain the updated community assignments $C^t$ (line \ref{alg:naive--leiden}). Finally, $C^t$ is returned, along with $K^t$ and $\Sigma^t$ as the updated auxiliary information (line \ref{alg:naive--return}).




\subsection{Our Parallel Delta-screening (DS) Leiden}
\label{sec:our-delta}

The pseudocode of our multicore implementation of Delta-screening (DS) Leiden is given in Algorithm \ref{alg:delta}. It uses modularity-based scoring to determine an approximate region of the graph in which vertices are likely to change their community membership \cite{com-zarayeneh21}. The algorithm accepts as input the previous $G^{t-1}$ and current snapshot of the graph $G^t$, edge deletions $\Delta^{t-}$ and insertions $\Delta^{t+}$ in the batch update, the previous community memberships of vertices $C^{t-1}$, weighted degrees of vertices $K^{t-1}$, and total edge weights of communities $\Sigma^{t-1}$. It outputs the updated community memberships $C^t$, weighted-degrees $K^t$, and total edge weights of communities $\Sigma^t$. The batch update, comprising edge deletions $(i, j, w) \in \Delta^{t-}$ and insertions $(i, j, w) \in \Delta^{t+}$, is sorted separately by their source vertex ID $i$ beforehand, as a preprocessing step.

\input{src/alg-naive}
\input{src/alg-delta}

In the algorithm, we first initialize a hashtable $H$, mapping communities to their associated weights, and affected flags $\delta V$, $\delta E$, and $\delta C$, indicating if a vertex, its neighbors, or its community is affected by the batch update (lines \ref{alg:delta--init}). Then, we parallelly iterate over edge deletions $\Delta^{t-}$ and insertions $\Delta^{t+}$. For each deletion $(i, j, w) \in \Delta^{t-}$ where $i$ and $j$ are in the same community, we mark the source vertex $i$, its neighbors, and its community as affected (lines \ref{alg:delta--loopdel-begin}-\ref{alg:delta--loopdel-end}). For each unique source vertex $i\ |\ (i, j, w) \in \Delta^{t+}$ in insertions belonging to different communities, we identify the community $c^*$ with the highest delta-modularity if $i$ moves to one of its neighboring communities and mark $i$, its neighbors, and the community $c^*$ as affected (lines \ref{alg:delta--loopins-begin}-\ref{alg:delta--loopins-end}). Deletions between different communities and insertions within the same community are disregarded. Using affected neighbor $\delta E$ and community flags $\delta C$, affected vertices in $\delta V$ are marked (lines \ref{alg:delta--loopaff-begin}-\ref{alg:delta--loopaff-end}). Next, similar to ND Leiden, we use $K^{t-1}$ and $\Sigma^{t-1}$, along with $\Delta^{t-}$ and $\Delta^{t+}$, to quickly yield $K^t$ and $\Sigma^t$ (line \ref{alg:naive--auxliliary}), define the needed lambda functions \texttt{isAffected()} (lines \ref{alg:delta--isaff-begin}-\ref{alg:delta--isaff-end}) and \texttt{inAffectedRange()} (lines \ref{alg:delta--isaffrng-begin}-\ref{alg:delta--isaffrng-end}), and run the Leiden algorithm, yielding updated community assignments $C^t$ (line \ref{alg:delta--leiden}). Finally, updated community memberships $C^t$ are returned, alongside $K^t$ and $\Sigma^t$ as updated auxiliary information (line \ref{alg:delta--return}).




\subsection{Our Dynamic-supporting Parallel Leiden}
\label{sec:our-leiden}

The main step of our Dynamic-supporting Parallel Leiden algorithm is given in Algorithm \ref{alg:leiden}. Unlike our implementation of Static Leiden \cite{sahu2023gveleiden}, in addition to the current graph snapshot $G^t$, it accepts as input the previous community membership of each vertex $C^{t-1}$, the updated weighted-degree of each vertex $K^t$, the updated total edge weight of each community $\Sigma^t$, and a set of lambda functions $F$ which determine if a given vertex is affected, or if it can be incrementally marked as affected (it is in the affected range). It outputs the updated community memberships of vertices $C^t$.

\input{src/alg-leiden}

In the algorithm, we commence by marking affected vertices as unprocessed (lines \ref{alg:leiden--mark-begin}-\ref{alg:leiden--mark-end}). Subsequently, the initialization phase follows, wherein we initialize the community membership of each vertex $C$ in $G^t$. Additionally, we initialize the total edge weight of each vertex $K'$, the total edge weight of each community $\Sigma'$, and the community membership $C'$ of each vertex in the current/super-vertex graph $G'$ (lines \ref{alg:leiden--init-begin}-\ref{alg:leiden--init-end}). After initialization, we conduct a series of passes (lines \ref{alg:leiden--passes-begin}-\ref{alg:leiden--passes-end}) of the local-moving and aggregation phases (limited to $MAX\_PASSES$). Within each pass, in line \ref{alg:leiden--local-move}, we execute the local-moving phase of the Leiden algorithm (Algorithm \ref{alg:leidenlm}), which optimizes community assignments. If the local-moving phase converges within a single iteration, it implies global convergence, prompting the termination of passes (line \ref{alg:leiden--globally-converged}). Conversely, if the drop in community count $|\Gamma|$ is deemed insignificant, indicating diminishing returns, we halt at the current pass (line \ref{alg:leiden--aggregation-tolerance}). Should the convergence conditions not be met, we progress to the aggregation phase. Here, we renumber communities (line \ref{alg:leiden--renumber}), update top-level community memberships $C$ using dendrogram lookup (line \ref{alg:leiden--lookup}), execute the aggregation phase (Algorithm \ref{alg:leidenag}), and adjust the convergence threshold for subsequent passes, i.e., perform threshold scaling (line \ref{alg:leiden--threshold-scaling}). The subsequent pass commences in line \ref{alg:leiden--passes-begin}. Following all passes, we do a final update of the top-level community membership $C$ of each vertex in $G^t$ via dendrogram lookup (line \ref{alg:leiden--lookup-last}), before ultimately returning it (line \ref{alg:leiden--return}).


\subsubsection{Local-moving phase of our Parallel Leiden}

The pseudocode detailing the local-moving phase of our Parallel Leiden algorithm is presented in Algorithm \ref{alg:leidenlm}. This phase iteratively moves vertices among communities in order to maximize modularity. Here, the \texttt{leidenMove()} function operates on the current graph $G'$, community membership $C'$, total edge weight of each vertex $K'$, total edge weight of each community $\Sigma'$, and a set of lambda functions as inputs, yielding the number of iterations performed $l_i$.

\input{src/alg-leidenlm}

Lines \ref{alg:leidenlm--iterations-begin}-\ref{alg:leidenlm--iterations-end} encapsulate the primary loop of the local-moving phase. In line \ref{alg:leidenlm--init-deltaq}, we initialize the total delta-modularity per iteration $\Delta Q$. Subsequently, in lines \ref{alg:leidenlm--loop-vertices-begin}-\ref{alg:leidenlm--loop-vertices-end}, we concurrently iterate over unprocessed vertices. For each vertex $i$, we perform vertex pruning by marking $i$ as processed (line \ref{alg:leidenlm--prune}). Next, we verify if $i$ falls within the affected range (i.e., it is permitted to be incrementally marked as affected), and if not, we proceed to the next vertex (line \ref{alg:leidenlm--affrng}). For each unskipped vertex $i$, we scan communities connected to $i$ (line \ref{alg:leidenlm--scan}), excluding itself, ascertain the optimal community $c*$ to move $i$ to (line \ref{alg:leidenlm--best-community-begin}), compute the delta-modularity of moving $i$ to $c*$ (line \ref{alg:leidenlm--best-community-end}), update the community membership of $i$ (lines \ref{alg:leidenlm--perform-move-begin}-\ref{alg:leidenlm--perform-move-end}), and mark its neighbors as unprocessed (line \ref{alg:leidenlm--remark}) if a superior community is identified. It's worth noting that this practice of marking neighbors of $i$ as unprocessed, which is part of the vertex pruning optimization, also aligns with algorithm of DF Leiden --- which marks its neighbors as affected, when a vertex changes its community. Thus, vertex pruning facilitates incremental expansion of the set of affected vertices without requiring any extra code. In line \ref{alg:leidenlm--locally-converged}, we examine whether the local-moving phase has achieved convergence (locally); if so, the loop is terminated (or if $MAX\_ITERATIONS$ is reached). Finally, in line \ref{alg:leidenlm--return}, we return the number of iterations performed by the local-moving phase $l_i$.


\subsubsection{Aggregation phase of our Parallel Leiden}

Finally, the pseudocode for the aggregation phase is depicted in Algorithm \ref{alg:leidenag}, where communities are amalgamated into super-vertices. Here, the \texttt{leide} \texttt{nAggregate()} function receives the current graph $G'$ and the community membership $C'$\ignore{as inputs}, and yields the super-vertex graph $G''$.

\input{src/alg-leidenag}

In the algorithm, we begin by obtaining the offsets array for the community vertices CSR $G'_{C'}.offsets$ in lines \ref{alg:leidenag--coff-begin}-\ref{alg:leidenag--coff-end}. This involves first counting the number of vertices belonging to each community using \texttt{countCommunityVertices()}, followed by performing an exclusive scan operation on the array. Subsequently, in lines \ref{alg:leidenag--comv-begin}-\ref{alg:leidenag--comv-end}, we concurrently iterate over all vertices, atomically populating vertices associated with each community into the community graph CSR $G'_{C'}$. Next, we derive the offsets array for the super-vertex graph CSR by overestimating the degree of each super-vertex in lines \ref{alg:leidenag--yoff-begin}-\ref{alg:leidenag--yoff-end}, by computing the total degree of each community using \texttt{communityTotalDegree()} and then performing an exclusive scan on the array. As a result, the super-vertex graph CSR exhibits holes/intervals between the edges and weights array of each super-vertex. Following this, in lines \ref{alg:leidenag--y-begin}-\ref{alg:leidenag--y-end}, we iterate over all communities $c \in [0, |\Gamma|)$. Here, we add all communities $d$ (along with their associated edge weight $w$) linked to each vertex $i$ belonging to community $c$ (via \texttt{scanCommunities()} defined in Algorithm \ref{alg:leidenlm}) to the per-thread hashtable $H_t$. Once $H_t$ encompasses all communities (alongside their weights) linked to community $c$, we atomically append them as edges to super-vertex $c$ within the super-vertex graph $G''$. Finally, in line \ref{alg:leidenag--return}, we return the super-vertex graph $G''$.


\subsection{Updating vertex/community weights}
\label{sec:our-update}

We now discuss the parallel algorithm for obtaining the updated the weighted degree of each vertex $K^t$ and total edge weight of each community $\Sigma^t$, given the previous community memberships of vertices $C^{t-1}$, weighted-degrees of vertices $K^{t-1}$, total edge weights of communities, and the batch update (consisting of edge deletions $\Delta^{t-}$ and insertions $\Delta^{t+}$). Its psuedocode is in Algorithm \ref{alg:update}.

\input{src/alg-update}

In the algorithm, we begin by initializing $K$ and $\Sigma$, the weighted-degree of each vertex, and the total edge weight of each community (line \ref{alg:update--init}). Then, across multiple threads, we iterate over both the sets of edge deletions $\Delta^{t-}$ (lines \ref{alg:update--loopdel-begin}-\ref{alg:update--loopdel-end}) and edge insertions $\Delta^{t+}$ (lines \ref{alg:update--loopins-begin}-\ref{alg:update--loopins-end}). For each edge deletion $(i, j, w)$ in $\Delta^{t-}$, we determine the community $c$ of vertex $i$ based on the previous community assignment $C^{t-1}$ (line \ref{alg:update--delc}). If $i$ belongs to the current thread's work-list, we decrement its weighted-degree by $w$ (line \ref{alg:update--delk}), and if community $c$ belongs to the work-list, we decrement its total edge weight by $w$ (line \ref{alg:update--delsigma}). Similarly, for each edge insertion $(i, j, w)$ in $\Delta^{t+}$, we adjust the vertex $i$'s weighted-degree and its community's total edge weight accordingly. Finally, we return the updated values of $K$ and $\Sigma$ for each vertex and community for further processing (line \ref{alg:update--return}).
